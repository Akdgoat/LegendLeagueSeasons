import argparse
import MySQLdb
import requests
import threading
import sys
import time
import traceback
from urllib.parse import quote_plus  # Python3 only

# used if no arguments passed in command line
# api_keys will be used in addition to ones passed via command line
database = "<database name>"
table = "<table name>"  # table created using legends_data.py
new_table = "<table name>"
sleep = 2  # raise this if thread count is too high or you get max files open erno 24
api_keys = []  # use more api keys if you get 429 errors

# create arg parser
parser = argparse.ArgumentParser()
parser.add_argument("-d", "--database")
parser.add_argument("-t", "--table", help="Table generated by legends_data.py")
parser.add_argument("-n", "--newtable")
parser.add_argument("-s", "--sleep", type=int)
parser.add_argument("-k", "--key", help="Argument can be used multiple times", action="append")
args = parser.parse_args()

# check command line arguments
if args.database:
    database = args.database
if args.table:
    table = args.table
if args.newtable:
    new_table = args.newtable
if args.sleep:
    sleep = args.sleep
if args.key:
    api_keys += args.key

# create database connection
db = MySQLdb.connect(host="localhost", user="root", passwd="", db=database, charset="utf8mb4")
db.autocommit(True)
cur = db.cursor()

# remove table and generate query to make new one
query = f"DROP TABLE IF EXISTS `{new_table}`"
cur.execute(query)
start = f"CREATE TABLE `{new_table}` ("
end = ") CHARACTER SET utf8mb4"
i, v = "INT", "VARCHAR"
fields1 = [("bestTrophies", i, 5),
           ("bestVersusTrophies", i, 5),
           ("tag", v, 15),
           ("townHallLevel", i, 2),
           ("townHallWeaponLevel", i, 2),
           ("builderHallLevel", i, 2),
           ("versusBattleWins", i, 8),
           ("warStars", i, 5)]
fields2 = [("legendTrophies", i, 5),
           ("bestSeasonID", v, 7),
           ("bestSeasonRank", i, 10),
           ("bestSeasonTrophies", i, 5),
           ("previousSeasonID", v, 7),
           ("previousSeasonRank", i, 10),
           ("previousSeasonTrophies", i, 5),
           ("bestVersusSeasonID", v, 7),
           ("bestVersusSeasonRank", i, 10),
           ("bestVersusSeasonTrophies", i, 5),
           ("previousVersusSeasonID", v, 7),
           ("previousVersusSeasonRank", i, 10),
           ("previousVersusSeasonTrophies", i, 5),]
troops = ['Barbarian', 'Archer', 'Goblin', 'Giant', 'Wall Breaker', 'Balloon', 'Wizard', 'Healer', 'Dragon', 'P.E.K.K.A', 'Minion', 'Hog Rider', 'Valkyrie', 'Golem', 'Witch', 'Lava Hound', 'Bowler', 'Baby Dragon Day', 'Miner', 'Raged Barbarian', 'Sneaky Archer', 'Beta Minion', 'Boxer Giant', 'Bomber', 'Super P.E.K.K.A', 'Cannon Cart', 'Drop Ship', 'Baby Dragon Night', 'Night Witch', 'Wall Wrecker', 'Battle Blimp', 'Electro Dragon']
spells = ['Lightning Spell', 'Healing Spell', 'Rage Spell', 'Jump Spell', 'Freeze Spell', 'Poison Spell', 'Earthquake Spell', 'Haste Spell', 'Clone Spell', 'Skeleton Spell']
heroes = ['Barbarian King', 'Archer Queen', 'Grand Warden', 'Battle Machine']
achievements = [('Bigger Coffers', 2), ('Get those Goblins!', 3), ('Bigger & Better', 2), ('Nice and Tidy', 5), ('Release the Beasts', 1), ('Gold Grab', 10), ('Elixir Escapade', 10), ('Sweet Victory!', 5), ('Empire Builder', 1), ('Wall Buster', 7), ('Humiliator', 7), ('Union Buster', 7), ('Conqueror', 7), ('Unbreakable', 6), ('Friend in Need', 10), ('Mortar Mauler', 7), ('Heroic Heist', 10), ('League All-Star', 2), ('X-Bow Exterminator', 7), ('Firefighter', 7), ('War Hero', 5), ('Treasurer', 12), ('Anti-Artillery', 7), ('Sharing is caring', 10), ('Keep your village safe', 1), ('Master Engineering', 2), ('Next Generation Model', 1), ('Un-Build It', 7), ('Champion Builder', 5), ('High Gear', 1), ('Hidden Treasures', 1), ('Games Champion', 10)]


def camel_case(string):
    string = string.replace("&", "and").replace("-", " ").replace(".", "").replace("!", "")
    words = [w.title() for w in string.split()]
    words[0] = words[0].lower()
    if len(words[0]) == 1:
        words[1] = words[1].lower()
    string = "".join(words)
    return string


# finish generating query and execute
fields = fields1 + fields2 + troops + spells + heroes + achievements
for i, f in enumerate(fields):
    if type(f) is str:
        fields[i] = (camel_case(f), "INT", 2)
    elif len(f) == 2:
        fields[i] = (camel_case(f[0]), "INT", f[1])
for f in fields:
    start += "%s %s(%s)," % f
start = start[:-1]
query = start + end
cur.execute(query)

# setup request parameters
headers = []
for key in api_keys:
    headers.append({"Accept": "application/json", "authorization": f"Bearer {key}"})
len_headers = len(headers)

# get tags from legends_data.py table
tags = []
query = f"SELECT `tag` FROM `{table}`"
cur.execute(query)
for row in cur.fetchall():
    tags.append(row[0])
print(f"Number of tags: {len(tags)}")

extras = {}


def add_extra(tag, i):
    global extras
    try:
        # make request
        ih = i % len_headers
        header = headers[ih]
        url = f"https://api.clashofclans.com/v1/players/{quote_plus(tag)}"
        r = requests.get(url, headers=header)

        # check status code
        if r.status_code == 200:
            pass
        else:
            if r.status_code != 404:
                print("STATUS ISSUE:", r.status_code)
            extras[tag] = None
            return

        # parse request - fields1
        p = r.json()
        tup_list = []
        for f in fields1:
            try:
                value = p[f[0]]
            except:
                continue
            try:
                value = int(value)
            except:
                pass
            tup = (f[0], value)
            tup_list.append(tup)

        # parse request - fields2
        if "legendStatistics" in p.keys():
            pls = p["legendStatistics"]
            if "legendTrophies" in pls.keys():
                tup_list.append(("legendTrophies", pls["legendTrophies"]))
            if "bestSeason" in pls.keys():
                plsbs = pls["bestSeason"]
                tup_list.append(("bestSeasonID", plsbs["id"]))
                tup_list.append(("bestSeasonRank", int(plsbs["rank"])))
                tup_list.append(("bestSeasonTrophies", int(plsbs["trophies"])))
            if "previousSeason" in pls.keys():
                plsbs = pls["previousSeason"]
                tup_list.append(("previousSeasonID", plsbs["id"]))
                tup_list.append(("previousSeasonRank", int(plsbs["rank"])))
                tup_list.append(("previousSeasonTrophies", int(plsbs["trophies"])))
            if "bestVersusSeason" in pls.keys():
                plsbs = pls["bestVersusSeason"]
                tup_list.append(("bestVersusSeasonID", plsbs["id"]))
                tup_list.append(("bestVersusSeasonRank", int(plsbs["rank"])))
                tup_list.append(("bestVersusSeasonTrophies", int(plsbs["trophies"])))
            if "previousVersusSeason" in pls.keys():
                plsbs = pls["previousVersusSeason"]
                tup_list.append(("previousVersusSeasonID", plsbs["id"]))
                tup_list.append(("previousVersusSeasonRank", int(plsbs["rank"])))
                tup_list.append(("previousVersusSeasonTrophies", int(plsbs["trophies"])))

        # parse request - troops
        trp = p["troops"]
        trpd = {}
        for tr in trp:
            if tr["name"] == "Baby Dragon":
                if tr["village"] == "home":
                    tr["name"] = "Baby Dragon Day"
                else:
                    tr["name"] = "Baby Dragon Night"
            trpd[tr["name"]] = int(tr["level"])
        for t in troops:
            try:
                tup_list.append((camel_case(t), trpd[t]))
            except:
                pass

        # parse request - spells
        if "spells" in p.keys():
            trp = p["spells"]
            trpd = {}
            for tr in trp:
                trpd[tr["name"]] = int(tr["level"])
            for t in spells:
                try:
                    tup_list.append((camel_case(t), trpd[t]))
                except:
                    pass

        # parse request - heroes
        if "heroes" in p.keys():
            trp = p["heroes"]
            trpd = {}
            for tr in trp:
                trpd[tr["name"]] = int(tr["level"])
            for t in heroes:
                try:
                    tup_list.append((camel_case(t), trpd[t]))
                except:
                    pass

        # parse request - achievements
        ach = p["achievements"]
        achd = {}
        for ac in ach:
            achd[ac["name"]] = int(ac["value"])
        for a in achievements:
            try:
                tup_list.append((camel_case(a[0]), achd[a[0]]))
            except:
                pass

        extras[tag] = tup_list
    except Exception as e:
        type_, value_, tb_ = sys.exc_info()
        err = "".join(traceback.format_exception(type_, value_, tb_))
        print(err)


# create thread objects - might take a lot of memory
threads = []
for i, t in enumerate(tags):
    t = threading.Thread(target=add_extra, args=(t, i))
    threads.append(t)

# run threads
start_time = time.time()
for i, t in enumerate(threads):
    if i % 200 == 0:
        print(f"{i} total threads started.")
        active = threading.active_count()
        print(f"{active} threads before sleep.")
        time.sleep(sleep)
        active = threading.active_count()
        print(f"{active} threads after sleep.")
        now = time.time()
        print(now - start_time, "\n")
    t.start()

# complete data collection output
time.sleep(10)
print("\n\n")
active = threading.active_count()
print(f"{active} threads.")
print("Finished data collection.")

# generate queries to pass data collected to table
queries, tuples = [], []
for tag in tags:
    try:
        info = extras[tag]
        if info is None:
            query = f"INSERT INTO `{new_table}` (`tag`) VALUES ('{tag}')"
            queries.append(query)
            tuples.append(None)
        else:
            tup_list = []
            start = f"INSERT INTO `{new_table}` ("
            middle = ") VALUES ("
            for i, info_tuple in enumerate(info):
                start += f"`{info_tuple[0]}`,"
                middle += "%s,"
                tup_list.append(info_tuple[1])
            start = start[:-1]
            middle = middle[:-1]
            query = start + middle + ')'
            queries.append(query)
            tup = tuple(tup_list)
            tuples.append(tup)
    except Exception as e:
        print(tag, "::", e)
print("Generated queries.\n")

# execute queries
for i, (query, tup) in enumerate(zip(queries, tuples)):
    if i % 10000 == 0:
        print(f"Done {i}.")
    if tup is None:
        cur.execute(query)
    else:
        cur.execute(query, tup)
print(f"Done {len(queries)}.")
print("Fully Done.")
